{"meta":{"title":"暴躁的关谷的个人博客","subtitle":"臭鱼之父","description":"个人小小站","author":"暴躁的关谷","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"数据结构学习笔记之单链表-01","slug":"blog-02","date":"2020-06-28T12:06:44.000Z","updated":"2020-06-28T12:13:21.164Z","comments":true,"path":"2020/06/28/blog-02/","link":"","permalink":"http://yoursite.com/2020/06/28/blog-02/","excerpt":"","text":"数据结构单链表的初始化、删除元素、插入元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node &#123;//定义单链表节点类型 int data;//数据域 struct Node *next;//指向下一个节点的指针&#125; Node, *LinkList;//Node侧重代表单个结点结构体，*LinkList定义时侧重代表整个链表，二者本质上没有区别//比如定义头结点“Node* L”，当在main中对链表进行CRUD操作或者链表需要作为形参在函数间传递时用“LinkList L”进行声明LinkList InitList() &#123; Node *L; //定义一个头结点 L = (Node *) malloc(sizeof(Node));//头结点申请地址 if (L == NULL) &#123; printf(\"内存不足，初始化失败\"); return NULL; &#125; else &#123; printf(\"单链表初始化成功\"); L-&gt;next = NULL;//头结点L指向NULL，单链表设置为空表 return L; &#125;&#125;//尾插法(在结点p后插入数据元素e)void InsertNextNode(Node *p, int e) &#123; if (p == NULL) &#123;//指定插入的位置i超出链表实际存放数据长度+1，不可以越过Null插入元素 printf(\"下标i越界\"); &#125; Node *s = (Node *) malloc(sizeof(Node));//开辟空间，存放即将插入的新节点s s-&gt;data = e;//将e存入s数据域 s-&gt;next = p-&gt;next;//p指向的后一元素替换为s来指向 p-&gt;next = s;//p更换为指向s&#125;//前插法（再结点p前面插入数据元素e，先后插，再交换值）void InsertPriorNode(Node *p, int e) &#123; if (p == NULL) &#123;//指定插入的位置i超出链表实际存放数据长度+1，不可以越过Null插入元素 printf(\"下标i越界\"); &#125; Node *s = (Node *) malloc(sizeof(Node));//开辟空间，存放即将插入的新节点s s-&gt;next = p-&gt;next;//p指向的后一元素替换为s来指向 p-&gt;next = s;//p更换为指向s s-&gt;data = p-&gt;data;//将p中的值放入s p-&gt;data = e;//p接受e，p数据域和指针域的值和s互换，实现在p前插入了s&#125;//任意位置插入结点void ListInsert(LinkList L, int i, int e) &#123;//传入需要在i位置插入e元素的单链表L if (i &lt; 1) &#123; printf(\"i值为非法值\");//i只能为int型正整数或0 &#125; LinkList p;//头指针p指向当前节点 int j = 0;//记录p的位置 p = L;//初始令p指向头结点L while (p != NULL &amp;&amp; j &lt; i - 1) &#123;//指针p从头结点L遍历链表，j自每次自增1，直到p的记录点j等于需要插入的位序i的前一结点处 p = p-&gt;next;//p通过将自身指向的下一元素的值，赋值给自己实现移动（每一个结点包含指向下一结点的信息next） j++;//记录位序 &#125; if (p == NULL) &#123;//指定插入的位置i超出链表实际存放数据长度+1，不可以越过Null插入元素 printf(\"下标i越界\"); &#125; Node *s = (Node *) malloc(sizeof(Node));//开辟空间，存放即将插入的新节点s s-&gt;data = e;//将e存入s数据域 s-&gt;next = p-&gt;next;//p当前的值为（i-1）位置的结点，p-&gt;next为p指向的下一结点，即i位置的结点，将p-&gt;next的值赋值给新节点s的指针域，令s-&gt;next指向i位置的结点 p-&gt;next = s;//令p指向新节点s完成插入（修改p-&gt;next即修改了结点（i-1）的指针域的值）&#125;//按位序删除(带头结点)void ListDelete(LinkList L, int i, int *e) &#123; if (i &lt; 1) &#123; printf(\"i值为非法值\");//i只能为int型正整数或0 &#125; LinkList p;//头指针p指向当前节点 int j = 0;//记录p的位置 p = L;//初始令p指向头结点L while (p != NULL &amp;&amp; j &lt; i - 1) &#123;//指针p从头结点L遍历链表，j自每次自增1，直到p的记录点j等于需要插入的位序i的前一结点处 p = p-&gt;next;//p通过将自身指向的下一元素的值，赋值给自己实现移动（每一个结点包含指向下一结点的信息next） j++;//记录位序 &#125; if (p == NULL || p-&gt;next == NULL) &#123;//指定插入的位置i超出链表实际存放数据长度+1，不可以越过Null插入元素 printf(\"下标i越界\"); &#125; Node *q = p-&gt;next; e = q-&gt;data; p-&gt;next = q-&gt;next; free(p);&#125;//按指定结点删除void DeleteNode(Node *p)&#123; if (p==NULL)&#123; printf(\"目标节点越界\"); &#125; Node *q=p-&gt;next; p-&gt;data=p-&gt;next-&gt;data;//p为最后一个结点时，会发生指针下标越界错误 p-&gt;next=q-&gt;next; free(p);&#125;//打印链表void show(LinkList L) &#123; Node *p; for (p = L-&gt;next; p != NULL; p = p-&gt;next) &#123; printf(\"%d\", p-&gt;data); &#125;&#125;//main函数void main() &#123; LinkList L = InitList(); //操作// ListInsert(L, 1, 3); show(L);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://yoursite.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构学习笔记之顺序表-01","slug":"blog-01","date":"2020-06-27T12:39:16.000Z","updated":"2020-06-27T13:04:19.661Z","comments":true,"path":"2020/06/27/blog-01/","link":"","permalink":"http://yoursite.com/2020/06/27/blog-01/","excerpt":"","text":"数据结构顺序表的动态初始化、动态增长、删除元素和插入元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;vss.h&gt;#define initSize 10typedef struct &#123; int *data; int MaxSize; int length;&#125;SeqList;void InitSize(SeqList *L);void IncreaseSize(SeqList *L, int len);bool ListInsert(SeqList *L, int i, int e);int ListDelete(SeqList *L, int i);void main()&#123; SeqList L; InitSize(&amp;L); for (int i = 0; i &lt; 6; i++) &#123; L.data[i]=i; printf(\"%d\\t\",L.data[i]); L.length++; &#125; printf(\"\\n\");//CRUD操作 ListDelete(&amp;L,4);//打印数组 printf(\"\\n\"); for (int j = 0; j &lt; L.length; j++) &#123; printf(\"%d\\t\",L.data[j]); &#125;&#125;//删除指定位置i的元素int ListDelete(SeqList *L, int i) &#123; if (i&lt;1 || i&lt;L-&gt;length)&#123; return \"Error\"; &#125; int e=L-&gt;data[i-1]; for (int j = i; j &lt; L-&gt;length; ++j) &#123; L-&gt;data[j-1]=L-&gt;data[j]; &#125; L-&gt;length--; return e;&#125;//插入指定元素到顺序表位置ibool ListInsert(SeqList *L, int i, int e) &#123; if (i&lt;1 || i&gt;L-&gt;length+1)&#123; return 0; &#125; if (L-&gt;length&gt;=L-&gt;MaxSize)&#123; return 0; &#125; for (int j = L-&gt;length; j &gt;= i; j--) &#123; L-&gt;data[j]=L-&gt;data[j-1]; &#125; L-&gt;data[i-1]=e; L-&gt;length++; return 1;&#125;//初始化顺序表void InitSize(SeqList *L) &#123; L-&gt;data=(int *)malloc(initSize*sizeof(int)); L-&gt;length=0; L-&gt;MaxSize=initSize;&#125;//增加动态数组的长度lenvoid IncreaseSize(SeqList *L, int len) &#123; int *p=L-&gt;data; L-&gt;data=(int *)malloc((L-&gt;MaxSize+len)*sizeof(int)); for (int i=0;i&lt;L-&gt;length;i++)&#123; L-&gt;data[i]=p[i]; &#125; L-&gt;MaxSize=L-&gt;MaxSize+len; free(p);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"我的第一篇Blog","slug":"我的第一篇Blog","date":"2020-06-25T14:22:47.000Z","updated":"2020-06-25T14:37:20.733Z","comments":true,"path":"2020/06/25/我的第一篇Blog/","link":"","permalink":"http://yoursite.com/2020/06/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"使用Typora编写MarkdownMarkdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式","categories":[{"name":"欢乐时光","slug":"欢乐时光","permalink":"http://yoursite.com/categories/%E6%AC%A2%E4%B9%90%E6%97%B6%E5%85%89/"}],"tags":[{"name":"饥荒","slug":"饥荒","permalink":"http://yoursite.com/tags/%E9%A5%A5%E8%8D%92/"},{"name":"唐臭鱼","slug":"唐臭鱼","permalink":"http://yoursite.com/tags/%E5%94%90%E8%87%AD%E9%B1%BC/"},{"name":"憨憨","slug":"憨憨","permalink":"http://yoursite.com/tags/%E6%86%A8%E6%86%A8/"},{"name":"帅气的我","slug":"帅气的我","permalink":"http://yoursite.com/tags/%E5%B8%85%E6%B0%94%E7%9A%84%E6%88%91/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"欢乐时光","slug":"欢乐时光","permalink":"http://yoursite.com/categories/%E6%AC%A2%E4%B9%90%E6%97%B6%E5%85%89/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://yoursite.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"顺序表","slug":"顺序表","permalink":"http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"},{"name":"饥荒","slug":"饥荒","permalink":"http://yoursite.com/tags/%E9%A5%A5%E8%8D%92/"},{"name":"唐臭鱼","slug":"唐臭鱼","permalink":"http://yoursite.com/tags/%E5%94%90%E8%87%AD%E9%B1%BC/"},{"name":"憨憨","slug":"憨憨","permalink":"http://yoursite.com/tags/%E6%86%A8%E6%86%A8/"},{"name":"帅气的我","slug":"帅气的我","permalink":"http://yoursite.com/tags/%E5%B8%85%E6%B0%94%E7%9A%84%E6%88%91/"}]}